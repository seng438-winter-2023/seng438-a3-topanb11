**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report #3 – Code Coverage, Adequacy Criteria and Test Case Correlation**

| Group \#:      | 22    |
| -------------- | --- |
| Student Names: | Topan Budiman    |
|                | Mark Ngu    |
|                | Jacob Schon    |
|                | Muhammed Shah     |

(Note that some labs require individual reports while others require one report
for each group. Please see each lab document for details.)

# 1 Introduction

For this lab, we will be utilizing white-box testing in order to create test cases that have sufficient statement, branch and condition coverage. The SUT that will be tested are Range and DataUtilities from the JfreeChart package. The goal is to create test cases that yield 90% statement, 70% branch and 60% condition coverage. 

# 2 Manual data-flow coverage calculations for X and Y methods

### RangeTest - contains()

#### DFG
![SENG 438](https://user-images.githubusercontent.com/65151396/222796106-61ff23d8-a626-492b-b1ec-6ffac9d97453.png)

#### Def-use Sets per Statement
| Statement      | Def-use set    |
| -------------- | --- |
| 1 | def = { value, this.lower, this.upper}<br> c-use = {}<br>p-use = {}|
| 2 | def = {}<br>c-use = {}<br>p-use = { value, this.lower }|
| 3 | def = {}<br>c-use = {}<br>p-use = {}|
| 4 | def = {}<br>c-use = {}<br>p-use = { value, this.upper }|
| 5 | def = {}<br>c-use = {}<br>p-use = {}|
| 6 | def = {}<br>c-use = { value, this.lower, this.upper }<br>p-use = {}|

#### DU-pairs per variable
| Variable      |  Defined in node (n) | dcu(v,n) | dpu(v,n) |
| --------| --- | --- | --- |
| value |1|{ 2, 4, 6 } | { (2, 3),  (2, 4), (4, 5), (4, 6) } |
| this.lower |1| { 2, 6 } | { (2, 3), (2, 4) } |
| this.upper |1| { 4, 6 } | { (4, 5), (4, 6) } |

#### Test Case Pair Coverage
| Test Case      | DU-pairs covered    |
| -------------- | --- |
| containsTestBLB | for value (1,2)<br>for this.lower (1,2)<br>for this.upper|
| containsTestLB | for value (1,2), (1, 4), (1, 6)<br>for this.lower (1, 2), (1, 6)<br>for this.upper (1, 4)|
| containsTestNOM | for value (1,2), (1, 4), (1, 6)<br>for this.lower (1, 2), (1, 6)<br>for this.upper (1, 4), (1, 6)|
| containsTestUB | for value (1,2), (1,4)<br>for this.lower (1, 2)<br>for this.upper (1, 4)|
| containsTestAUB | for value (1,2), (1, 4), (1, 6)<br>for this.lower (1, 2), (1, 6)<br>for this.upper (1, 4), (1, 6)|

#### Calculate DU-pair Coverage
<img width="661" alt="Screenshot 2023-03-03 at 11 11 38 AM" src="https://user-images.githubusercontent.com/65151396/222796168-4105f6f8-2cc3-4f2c-bf08-aa34974ebe03.png">


# 3 A detailed description of the testing strategy for the new unit test

For testing strategy, we will be utilizing white-box testing since we have access to the source code of the SUT. For testing strategy, we will start by observing the test cases we created previously and if they are up to par with the coverage requirements. Once we are done that, we’ll improve the coverage of any tests that lack sufficient coverage. This will be done by ensuring that all statements are covered, all branches are covered and all conditions are satisfied. This will ensure that we have the highest coverage possible in our test suite.

# 4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage

### expandToInclude()
To ensure there is sufficient coverage for this method, we had to analyze the source code carefully to ensure we are covering all cases. Since this method had multiple if-statements, we created test cases to satisfy all possible conditions so that all branches were covered. Some test cases fulfilled multiple conditions on one run so we were able to write fewer tests while still reaching 100% coverage.

### getCumulativePercentages()
For this method, there were multiple for-loops and if-statements so we had to develop our test cases to ensure all possible statements and branches were covered. However, some statements were impossible to reach which is why the maximum coverage for this method was 83%. For example, for one of the for-loops, the counter is initialized to 0 and there is a conditional that requires the counter to be greater than the size of the array. However, this is impossible since the counter will always be set to 0 so that for-loop and the statements inside including the if-statement will always be missed.


# 5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)

Text…

# 6 Pros and Cons of coverage tools used and Metrics you report

Text…

# 7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation.

Text…

# 8 A discussion on how the team work/effort was divided and managed

Text…

# 9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab

One difficulty we encountered was that some branches were impossible to reach. This is because for some conditional statements, there is already error-checking prior to the condition, making it impossible to enter the conditional block.

# 10 Comments/feedback on the lab itself

The lab was very straight-forward and it was helpful that all necessary files were provided.
